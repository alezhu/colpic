//
// Created by alezhu on 19.12.2023.
//

#include "gcode_handler.h"

#include <algorithm>
#include <format>
#include <fstream>
#include <unordered_set>
#include <utility>

#include "global.h"


using namespace std::literals;
constexpr auto marker_thumbnail_begin{"; thumbnail begin"sv};
constexpr auto marker_thumbnail_end{"; thumbnail end"sv};
constexpr auto marker_thumbnail_size{"600x600"sv};
constexpr auto marker_printer_model{"; printer_model = "sv};
constexpr auto marker_gimage{";gimage:"sv};
constexpr auto marker_gimage_old{";;gimage:"sv};
constexpr auto marker_simage{";simage:"sv};

gcode_handler::gcode_handler(std::filesystem::path path)
  : m_path(std::move(path)),
    m_printer_model_index(-1),
    m_gimage_index(-1),
    m_simage_index(-1)
{
  _parse();
}

std::string gcode_handler::read_base64_thumbnail(std::optional<std::string> _size) const
{
  std::stringstream result;
  auto& size = _size.has_value() ? _size.value() : marker_thumbnail_size;
  for (const auto iChunk: m_thumbinails)
  {
    auto& stream = m_chunks[iChunk];
    stream->seekg(0);
    std::string line;
    if (std::getline(*stream, line))
    {
      if (line.find(size.data(), size.size()) != std::string::npos)
      {
        while (std::getline(*stream, line))
        {
          if (line == marker_thumbnail_end)
          {
            return result.str();
          }
          line.erase(std::find_if(line.rbegin(), line.rend(), [](unsigned char ch) {
            return !std::isspace(ch);
          }).base(), line.end());
          std::string_view view{line};
          view.remove_prefix(2); //;<space>
          result << view;
        }
      }
    }
  }

  throw std::logic_error(
    std::format("Correct size thumbnail is not present: Make sure, that your slicer generates a thumbnail with size {}",
                size));
}

std::string gcode_handler::get_printer() const
{
  std::string result;

  if (m_printer_model_index >= 0)
  {
    auto& chunk = m_chunks[m_printer_model_index];
    if (std::getline(*chunk, result))
    {
      result.erase(0, marker_printer_model.size());
      result.erase(result.find_last_not_of('\r') + 1);
    }
  }
  return result;
}

bool gcode_handler::has_gimage_or_simage() const
{
  return m_gimage_index != -1 || m_simage_index != -1;
}

void gcode_handler::add_gimage(std::string_view data)
{
  m_gimage = data;
}

void gcode_handler::add_simage(std::string_view data)
{
  m_simage = data;
}

void gcode_handler::save(bool exclude_thumbnails) const
{
  std::ofstream stream{m_path.c_str()};
  if (!m_gimage.empty())
  {
    stream << m_gimage;
  }

  if (!m_simage.empty())
  {
    stream << m_simage;
  }

  stream
      << ";Thumbnail generated by the "
      << PROGRAM_NAME
      << " - post processing script (https://github.com/alezhu/colpic)\r"
      << ";Just mentioning \"Cura_SteamEngine X.X\" to trick printer into thinking this is Cura and not Prusa gcode\r\r";

  const std::unordered_set<size_t> th_set{m_thumbinails.cbegin(), m_thumbinails.cend()};

  for (auto i = 0; i < m_chunks.size(); ++i)
  {
    if (exclude_thumbnails and th_set.contains(i))
    {
      continue;
    }
    const auto& chunk = m_chunks[i];
    chunk->seekg(0);
    stream << chunk->str();
  }

  stream.close();
}

void gcode_handler::_parse()
{
  enum CHUNK_TYPE
  {
    NORMAL,
    THUMBNAIL_B64,
    PRINTER,
    GIMAGE,
    SIMAGE,
  };

  std::ifstream stream{m_path.c_str()};
  if (stream.is_open())
  {
    std::string line;
    auto chunk = _new_chunk();
    CHUNK_TYPE prev_chank_type{NORMAL};
    while (std::getline(stream, line))
    {
      while (true)
      {
        if (line.size() > 1)
        {
          if (line.starts_with(marker_thumbnail_begin))
          {
            prev_chank_type = THUMBNAIL_B64;
            chunk = _new_chunk();
            auto index = m_chunks.size() - 1;
            m_thumbinails.push_back(index);

            *chunk << line << std::endl;

            while (std::getline(stream, line))
            {
              *chunk << line << std::endl;
              if (line.starts_with(marker_thumbnail_end))
              {
                break;
              }
            }
            chunk = _new_chunk();
            break;
          }

          if (line.starts_with(marker_printer_model))
          {
            prev_chank_type = PRINTER;
            chunk = _new_chunk();
            m_printer_model_index = m_chunks.size() - 1;
            *chunk << line << std::endl;
            chunk = _new_chunk();
            break;
          }

          if (prev_chank_type != GIMAGE && (line.starts_with(marker_gimage) || line.starts_with(marker_gimage_old)))
          {
            prev_chank_type = GIMAGE;
            chunk = _new_chunk();
            m_gimage_index = m_chunks.size() - 1;
            *chunk << line << std::endl;
            while (std::getline(stream, line))
            {
              if (!line.starts_with(marker_gimage))
              {
                break;
              }
              *chunk << line << std::endl;
            }
            chunk = _new_chunk();
            continue;
          }

          if (prev_chank_type != SIMAGE && line.starts_with(marker_simage))
          {
            prev_chank_type = SIMAGE;
            chunk = _new_chunk();
            m_simage_index = m_chunks.size() - 1;
            *chunk << line << std::endl;
            while (std::getline(stream, line))
            {
              if (!line.starts_with(marker_simage))
              {
                break;
              }
              *chunk << line << std::endl;
            }
            chunk = _new_chunk();
            continue;
          }
        }
        (*chunk) << line << std::endl;
        prev_chank_type = NORMAL;
        break;
      }
    }
  }
}

std::stringstream* gcode_handler::_new_chunk()
{
  return m_chunks.emplace_back(new std::stringstream{}).get();
}
